# 깊이 우선 탐색(DFS)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class BOJ_11403_경로찾기 {
	static ArrayList<Integer>[] node;
	static int[][] graph;
	static boolean[] visited;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] line;

		// 정점의 개수 입력받음
		int N = Integer.parseInt(br.readLine());

		// 그래프 값을 입력받기 위한 N+1 x N+1 크기의 배열
		graph = new int[N+1][N+1];

		// 그래프 값 입력받음
		for(int i = 1; i <= N; i++) {
			line = br.readLine().split(" ");
			for(int j = 1; j <= N; j++) {
				graph[i][j] = Integer.parseInt(line[j-1]);
			}
		}

	    // 인접 리스트를 담을 배열 생성
		node = new ArrayList[N+1];
		// 방문 확인을 위한 배열 생성
		visited = new boolean[N+1];

        // 인접 리스트 초기화
		for(int i = 1; i < N+1; i++) {
			node[i] = new ArrayList<Integer>();
		}

        // 각 노드의 인접 노드 저장
		for(int i = 1; i <= N; i++) {
			for(int j = 1; j <= N; j++) {
				if(graph[i][j] == 1) {
					node[i].add(j);
				}
			}
		}

		// 깊이 우선 탐색 실시하고 결과 출력
		for(int V = 1; V <= N; V++) {
			for(int v : node[V]) 
				DFS(v);

			for(int i = 1; i < visited.length; i++) {
				if(visited[i]) {
					System.out.print(1 + " ");
				} else {
					System.out.print(0 + " ");
				}
			}
			System.out.println();
			visited = new boolean[N+1];
		}
	}

	// 깊이 우선 탐색 메서드
	public static void DFS(int V) {	
		// 방문한 적이 있다면 메서드 종료
		if(visited[V]) {
			return;
		}

		// 해당 노드를 방문 표시
		visited[V] = true;
		
		// 해당 노드에 담겨있는 인접노드를 재귀호출로 탐색
		for(int v : node[V]) {
			DFS(v);
		}
	}
}
```
